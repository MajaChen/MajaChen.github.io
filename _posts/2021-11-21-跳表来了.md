---
layout: post
title: 跳表
subtitle: skiplist
cover-img: /assets/img/2.jpg
thumbnail-img: /assets/img/animals/TawnyFrogmouth.jpg
tags: [数据结构]
---


# 跳表

## 跳表的概念 

&emsp;&emsp;从单链表的查找说起，假设有如图所示的一个单链表，元素按照正序排列，在该链表上执行查找操作，只能从头到尾依次遍历，时间复杂度是O(N)。

![image-20211120142504058](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120142504058.png)



&emsp;&emsp;如果在原始链表的基础上，增加如下图所示的索引，那么查找元素时，就可以借助索引降低时间复杂度。

![image-20211120143249130](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120143249130.png)

&emsp;&emsp;比如，我们查找元素9，如果不借助索引，查找路径由图中黑色箭头标识，如果借助索引，查找路径由图中红色箭头标识。我们发现，红色路径的长度比黑色路径将近缩短了一半(距离长度由路径上的节点数表示)，因为相比于黑色路径红色路径**跳过了部分元素**，从而加快了查找速度，跳表也因此得名。

![image-20211120143544881](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120143544881.png)

&emsp;&emsp;如果我们再接再厉，在一级索引的基础上继续建立二级索引，那么理论上，查找一级索引的时候，借助二级索引，又可以将查找路径的长度缩短一半，这一查找过程十分类似于二分查找。我们继续建立索引，直到顶级索引的结点个数为2：

![image-20211120144733638](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120144733638.png)

&emsp;&emsp;查找操作具体的时间复杂度我们稍后再议。我们可以看到，通过引入额外的多级索引，加快了节点的查找速度，是典型的以时间换空间的策略。当元素数量比较大，加速效果会尤其明显：假设有10000个元素，现需要查找元素7999，通过索引可跳跃前5000个元素，,再通过索引可跳跃5000至7500之间的2500个元素...

## 跳表的操作

### 查找元素

&emsp;&emsp;查找某个指定元素需要按照索引层级，从上往下、从左往右依次遍历跳表。比如上图查找元素9，就从顶级索引开始遍历，当发现9小于13时，就转入二级索引，一直下钻到原始链表。在原始链表中，当发现存在大于查找元素的结点存在时就说明查找元素不存在。例如查找元素6：

![image-20211120150735688](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120150735688.png)

&emsp;&emsp;查找元素时间复杂度：我们发现，在遍历的过程中，每一层访问的元素数量不会超过3，而跳表的层数等于lgN。所以查找操作的时间复杂度是O(3*lgN)=O(lgN)。

### 插入元素

&emsp;&emsp;插入操作的难点在于：插入之后如何同步更新索引，使跳表始终满足定义。上文严格按照每隔两个元素结点建立一个索引结点的规范，最终产生了N/2个索引结点。但是实际上，索引的分布可以是随机的，可以从N个节点中随机地选择N/2个结点建立索引。如下图所示，查找元素8时，借助索引，仍然可以跳过一半的元素、达到加速的效果：

![image-20211120152311195](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120152311195.png)

&emsp;&emsp;索引分布的随机性确实可能会对元素的查找操作带来不利影响，比如上图中查找元素4，通过索引查找与不通过索引查找效率一样。但是在数据量足够大的情况下，我们可以认为随机选取的索引是均匀分布的，不会对数据的查找造成影响。

&emsp;&emsp;在索引随机选取的前提下，我们期望：
- N个元素中有1/2个元素建立一级索引；

- N个元素中有1/4个元素建立二级索引；

  ...

- N个元素中有1/(2的X次方)个元素建立X级索引；


&emsp;&emsp;那么具体到每一个新插入元素：

- 它有1/4的概率建立一级索引；

- 它有1/8的概率建立二级索引；

  ...

- 它有1/(X+1次方)的概率建立X级索引；


&emsp;&emsp;这里引入了一个问题：以一级索引为例，为什么期望N个元素中有1/2个元素建立一级索引，而新插入元素仅要求有1/4的概率建立一级索引？1/2与1/4之间的差距是怎么产生的？

&emsp;&emsp;因为在建立X级索引的时候，也会附带的建立X-1、X-2...级索引。例如，建立三级索引的时候，也会附带的建立二级索引和一级索引。

&emsp;&emsp;所以如下公式可以解释这个差异：1/2=(1/4)+(1/8+1/16+...)。左边的1/2表示期望N个元素中有1/2个元素建立一级索引，中间的1/4表示新插入元素建立一级索引的直接概率是1/4，右边的1/8+1/16+...表示新插入元素由于要建立更高级索引而附带建立一级索引的间接概率。

&emsp;&emsp;所以，插入操作的第一步是判断该元素需要建立几级索引，我们将这个逻辑抽象为randomLevel()方法:

- randomLevel()以1/2的概率返回1，表示不需要建立索引；

- randomLevel()以1/4的概率返回2，表示需要建立一级索引；

- randomLevel()以1/8的概率返回3，表示需要建立二级索引；

  ...


&emsp;&emsp;它的实现代码如下：

```
// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：
//        1/2 的概率返回 1
//        1/4 的概率返回 2
//        1/8 的概率返回 3 以此类推
private int randomLevel() {
  int level = 1;
  // 当 level < MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1
  while (Math.random() < SKIPLIST_P && level < MAX_LEVEL)
    level += 1;
  return level;
}
```

&emsp;&emsp;SKIPLIST_P一般被设为0.5，即该条件通过的概率是1/2，从而实现每两个元素中选取一个元素作为索引的目的。可以通过调低SKIPLIST_P来增大索引之间的“间隙”。

&emsp;&emsp;一旦确定了新插入元素的索引层数，就遍历跳表，在遍历的过程中同时插入元素和索引。比如，我们要在下图中，插入元素6：

![image-20211120160224453](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120160224453.png)

&emsp;&emsp;首先通过randomLevel()函数确定需要建立几级索引，假设randomLevel()返回3，表示需要对该元素建立二级索引；然后开始遍历跳表：

- 三级索引不需要更新，从结点1转入二级索引；

- 二级索引需要更新，在1与7之间插入新结点，从结点1转入一级索引；

- 一级索引需要更新，在4与7之间插入新结点，从结点4转入原始链表；

- 原始链表需要更新，在5与7之间插入新结点，结束。


![image-20211120162519713](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20211120162519713.png)

&emsp;&emsp;跳表的实际插入过程可能会因实现方式的不同而有所差异。分析插入的时间复杂度：每一层的插入操作都可以在常量时间复杂度内完成，因此与查找操作一样，跳表的插入操作时间复杂度也是O(lgN)。



### 删除操作

&emsp;&emsp;删除操作需要同步地删除元素对应的索引结点。删除与查询类似，区别在于在删除的过程中，对发现的结点要执行删除操作，而在单链表中删除操作可在常量时间复杂度内完成。因此删除操作的时间复杂度也是O(lgN)。



## 跳表的空间复杂度

&emsp;&emsp;跳表采取以空间换时间的策略，通过建立额外的索引加快元素查找速度。如果从N个元素中，选取N/2个元素建立索引，那么最终索引结点的数量是：N/2+N/4+N/8+......2=N-2，所以空间复杂度是O(N)。如果我们扩大索引之间的“间隙”，比如每3元素建立一个索引，那么最终索引结点的数量是： n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，尽管仍然是O(N)的空间复杂度，但是有明显改善。然而由于索引之间“间隙”的增大，查找元素需要付出的时间复杂度也会相应地提高。因此，应该根据应用场景的特点在时间与空间之间做出合理的权衡。比如，**redis ZSET的SKIPLIST_P被设为0.25，表示每四个元素会产生一个索引。**

&emsp;&emsp;考虑这样一种情况：跳表的每个数据元素是一个复杂的结构体，通过结构体的单个字段对其排序，由于索引只需要存储排序字段，那么此时索引耗费的额外空间相比于数据存储占用的空间将显得微不足道，借助索引进行查询加速将会非常”划算“。



## 跳表的应用

&emsp;&emsp;跳表相比与红黑树，它的实现方式更加简单，实现过程更易于理解，最重要的是，跳表还可高效地支持**区间查找**操作：在O(lgN)时间复杂度内完成区间首尾结点的定位，然后遍历原始链表，取出区间内所有元素。**这也是redis 采用跳表来实现ZSET而不是红黑树的重要原因。**

&emsp;&emsp;跳表最经典的应用是redis ZSET。



## 跳表的Golang实现

&emsp;&emsp;源代码及中文注释见我[GitHub仓库](https://github.com/MajaChen/skiplist)。





