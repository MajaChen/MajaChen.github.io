---
layout: post
title: 秋招笔记之数据库
subtitle: 秋招 数据库 计算机专业基础
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/animals/FatherEagle.jpg
share-img: /assets/img/path.jpg
tags: [秋招,数据库,计算机专业基础]
---

# 主题1：并发控制

##### 1.事务的基本概念

一组操作，这些操作要么全做，要么全不做；



##### 2.事物的特性——ACID

1.  原子性：事务包含的操作要么全做，要么全不做；
2.  一致性：事务的执行会保证数据的一致性；
3.  持久性：事务的成功执行可以保证数据的永久性存储；
4.  隔离性：事务之间的执行互不影响；

事务与SQL语句的关系

在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。



##### 事务的隔离级别

1. 读未提交：事务A可读取事务B**未提交的数据**；
2. 读已提交：事务A读取的数据一定是已经提交的，修复脏读，但是事务A两次读取同一条数据，中间穿插了事务B对该数据的修改，出现了**不可重复读**的问题，**二级封锁协议可实现**。
3. 可重复读：事务A读取的数据一定是已经提交的，而且在事务A执行期间事务B不可穿插进来修改；无法避免幻读；——三级封锁协议，**三级封锁协议可实现。** 
4. 序列化：事务之间是严格地顺序执行；

InnoDB的默认数据库访问级别是什么？——可重复读

   

##### 并发操作带来的数据不一致问题

丢失修改：事务A对数据的修改被事务B覆盖了；

不可重复读：事务A两次读取同一份数据，中间事务B修改了改数据；

读脏数据：事务A读取的数据过段时间之后被回滚了；

幻读：事务A两次读取同一范围内的数据(比如某张表)，发现事务总量不一致；



##### 并发控制的主要技术之——封锁

事务A在访问某个数据对象时就锁定该对象，其他事务在此期间不能访问该数据对象，待到操作结束结束之后释放锁定；



##### 共享锁-读锁

##### 排他锁-写锁



##### 读锁与写锁之间的优先级

读写锁可以有不同的操作模式优先级：

1. 读操作优先：只要数据对象上的读锁还没有被释放，后续的读操作可免去锁申请直接访问数据，写操作必须等待至系统没有读操作了。允许最大并发，但写操作可能饿死。

2. 写操作优先：一旦已经开始的读操作完成，等待的写操作立即获得锁。

3. 未指定优先级

   

##### 读写锁内部实现——读锁的优先级大于写锁：

使用两把互斥锁与一个整数计数器实现。计数器*b*跟踪被阻塞的读线程。互斥锁*r*保护*b*，供读者使用。互斥锁*g* (指"global")确保写操作互斥。伪代码：

```
// Begin Read
Lock r.
Increment b.
If b = 1, lock g.
Unlock r.
// End Read
Lock r.
Decrement b.
If b = 0, unlock g.
Unlock r.

// Begin Write
Lock g.

// End Write
Unlock g.
```

##### 封锁协议

##### 三级封锁协议

1. 一级封锁协议

   写数据之前加X锁，事务结束释放；解决丢失修改问题；

2.   二级封锁协议

   写数据之前加X锁，事务结束释放；

   读数据之前加S锁，读完释放；解决读脏数据问题

3.   三级封锁协议

   写数据之前加X锁，事务结束释放；

    读数据之前加S锁，事务结束释放；解决不可重复读问题

   

##### 封锁带来的问题：

1. 活锁：某个锁申请迟迟得不到满足；

2. 死锁：“吃着碗里，望着锅里”。

   

##### 如何预防死锁

资源的一次性分配

资源的的顺序封锁



##### 如何监测死锁

超时：事务申请某个资源的等时间太长；

等待图：等待图出现环路；

InnoDB如何防止死锁？



##### 可串行化调度

有两个事务包含了多个操作，如果调度方式能够保证这两个事务是穿行执行的，那这个调度被称作可串行化调度，可串行化调度一定是正确的调度。



##### 冲突可串行化调度

如果一个调度存在冲突操作(读写操作，写写操作)，通过交换非冲突的操作，把这个调度调整成一个串行化的调度，那么就称该调度为冲突可串行化调度。冲突可串行化调度一定是正确的调度。



##### 两段锁协议(2PL协议)

对锁的操作明确地分为两个阶段：申请阶段和释放阶段；

两段锁协议能够保证调度的可串行性，但是无法避免死锁；



##### 多粒度封锁协议

对分别不同粒度的数据施加锁；比如写入访问某个元组，就在该元组上加锁；要写入某张表，就在该表上加锁。这样带来了一个问题：对某张表加锁，我既要检查低层数据对象(元组)的加锁情况，又要检查高层数据对象的加锁情况，繁琐！



##### 意向锁

对某个数据对象加意向锁，比如加一个意向读锁，就表明我准备对该数据对象某个低层数据对象加读锁。比如我对某张表加意向读锁，那我就准备对该表下的某个元组加读锁。那么这样一来，下次我准备对该表加写锁，就不用再逐个地检查该表的每个元组的加锁情况。



##### 多版本并发控制——讲原理

它最大的优点是使得读操作与写操作之间不冲突。事务A的写操作会创建数据对象的一个新的版本，那么在此期间事务B的读操作可以读取旧版本数据，从而避免了与读写操作之间的冲突。事务A完成操作之后会延迟提交，等到事务B提交，然后用新版本数据代替旧版本数据。这样每个数据对象最多有一个版本，而且读操作与写操作之间不冲突，提高了系统的并发度。

# 主题2：索引

## 以MySQL-InnoDB引擎为例

##### 讲清楚索引是什么

用于加快数据的查找速度，可以类比新华字典：要查找的汉字很多，我们可能需要把一本厚厚的字典从头翻到尾才能找到那个汉字。但是如果我们可以建立目录，要查找某个汉字，只需先看目录，目录只有几十页，可以帮助我们快读定位它到汉字在哪一页或者哪几页，然后再直接翻到对应的页数就可以快速找到汉字了。从数据库查找数据也一样，先去索引中找到对应的索引条目，定位到这条数据到底在哪，然后再去找数据。这是索引最基本的功能。

目录有几十页，如果在查找目录的时候不想一页一页地翻，可建立字母表加快目录的查找速度。同样地，我们用B+树或者Hash表来组织索引以加快索引的查找速度。



##### 索引的适用场景

小表：索引查找不如全表扫描；

特大表：索引本身的体积很大，在索引中进行查找耗时很长。这种情况可考虑对表进行分区。

因此索引仅适用于中表和大表。



##### B-树

## B-树

![B-树](https://gitee.com/xinyuanchen/image_collection/raw/master/B-树.png)

特征：

键既分布于叶结点，也分布于非叶节点

键值之间的大小关系类似于排序二叉树



##### B+树

![B-树](https://gitee.com/xinyuanchen/image_collection/raw/master/B+树.png)

特征：

键只分布于叶结点，非叶结点存在的唯一目的是查找

键值之间的大小关系类似于排序二叉树

叶结点之间通过next指针相连，所以B+树不仅支持按值查找，也支持顺序遍历。



##### BTree索引的基本概念

基于B+树组织索引条目，叶子结点保存了指向记录的指针，数据的存储结构如下：

![image-20210823145402362](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210823145402362.png)



##### BTree索引的数据查询过程

1）根据关键字找索引项：根据给定的关键字，在B+树中由上到下寻找叶节点

2)根据索引项找记录：根据叶节点提供的指向记录的指针，获取记录



##### BTree索引索引项组织

假设有如下数据表：

```
CREATE TABLE People
( last_name varchar( 50) not null,
first_name varchar( 50) not null,
dob date not null,
gender enum(' m', 'f') not null,
key( last_name, first_name, dob) );
```

在last_name、first_name、dob三列上建立了一个联合索引。索引条目 中 包 含 了 last_name、 first_name 和 dob 列 。类似于基数排序，条目首先根据last_name排序，last_name相同再根据first_name排序，first_name相同再根据dob排序。

![image-20210823152652041](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210823152652041.png)



##### BTree索引匹配规则

| 名称                                 | 场景                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 全值匹配                             | 查询条件包含所有索引列，但是查询条件列的顺序<br />与索引列的顺序必须一致 |
| 最左前缀匹配                         | 查询条件包含索引最左列                                       |
| 列前缀匹配                           | 查询条件包含最左列的前缀，比如lastname like 'Allen'          |
| 范围值匹配                           | 查询条件包括最左列的范围查询，比如 lastname begin_with('Allen') |
| 第一列范围匹配、<br />第二列精确匹配 | 查询条件包括最左列的范围查询、第二最左列的精确查询           |



##### BTree索引匹配陷阱

| 名称               | 场景                                                         |
| ------------------ | ------------------------------------------------------------ |
| 最左列的陷阱       | 查询条件不以索引最左列开始，则无法使用索引                   |
| 跳过索引列中的陷阱 | 查询条件跳过索引中的某些列(不讨论最左列)，则该列以左的列无法使用索引 |
| 范围查询的陷阱     | 查询条件对某个索引列使用范围查询，则该列以左的列无法使用索引 |
| 表达式的陷阱       | 查询条件中在一个表达式中使用索引列，则无法使用索引           |
|                    |                                                              |

##### BTree索引的其他(非排序)用途

范围查询：B+树支持叶子结点的顺序访问；

order by：直接按照hash给定的顺序读取记录，避免服务器层对数据重排序；

group by：直接按照hash给定的顺序读取记录，避免服务器层对数据重分组；



##### hash表

hash表是一种数据存储结构，可根据数据的某些特征(关键字)，通过hash函数的映射，快速定位到数据的存储位置。它适合存储k-v型的数据，根据key快速提取val。但是**hash表不会存储key**，key仅用于hash映射。hash表往往用一个数组来实现，通过hash函数将key映射成为数组下标，然后存入val。为了解决hash冲突，通常采用拉链法，每个数组元素又是一个链表结构。



##### hash函数

hash函数用于实现关键字到存储位置的映射，它的输入是key，输出是数据存放位置。



##### hash索引

基于Hash表来组织索引条目，key是记录的索引列，val是指向记录的指针。



##### hash索引的查询过程

1)根据关键字计算索引项存储位置

2)获取存储项

3)获取记录

所以万变不离其宗，hash索引也是用来组织索引条目的一种手段。



##### 自适应hash索引

如果InnoDB发现某些索引条目被使用得非常频繁，就会为这些索引条目额外建立hash索引，下一次就直接使用hash索引去查找记录，而不是通过BTree索引。



##### 自定义hash索引

对长列计算CRC编码，基于编码建立BTree等其他类型索引，查询长列时计算其CRC编码然后到BTree索引中查找记录。



##### 聚簇索引概念

聚簇索引是数据的一种存储方式：记录与索引在物理上相邻存放，与之相对应，非聚簇索引的记录与索引在物理上分开存放。InnoDB的叶结点存放完整记录。



![image-20210823213504787](C:\Users\chxy\AppData\Roaming\Typora\typora-user-images\image-20210823213504787.png)

（注意：叶结点存储了记录的全部列，但是内部结点只存储了记录的索引列。）



##### InnoDB主索引

索引项与记录在一起的索引，也被称为一级索引。



##### InnoDB主索引与主键

InnoDB引擎默认会把主键作为索引，并根据主索引的顺序来存储记录。如果没有指定主键，InnoDB引擎会创建一个默认索引，该索引的值是随机生成的整形数字。



##### InnoDB主索引的查询过程

1)根据给定的关键字寻找主索引叶节点，取出数据行。因此主索引访问速度非常快。



##### InnoDB辅助索引

索引项与记录不在一起的索引，叶节点保存了主键值，也被称为二级索引。



##### InnoDB辅助索引的查询过程

1)根据给定的关键字寻找辅助索引叶节点，取出主键值

2)根据主键值寻找主索引叶节点，取出数据行

所以获取一条记录需要访问两次索引



##### InnoDB主索引的数据分布

先创建如下一张表：

```
CREATE TABLE layout_test (
col1 int NOT NULL,
col2 int NOT NULL,
PRIMARY KEY( col1),
KEY( col2) );
```

该表的主键是col1，所以会基于col1建立主索

![InnoDB存储引擎主键分布](https://gitee.com/xinyuanchen/image_collection/raw/master/InnoDB存储引擎主键分布.png)



##### InnoDB辅助索引的数据分布

![image-20210823211128916](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210823211128916.png)



二级索引的叶子结点仅存储了索引列和主键列。



##### 非聚簇索引的数据分布

以MyISAM引擎为例。MyISAM引擎不存在主索引与辅助索引之分，数据按照插入顺序排序

![image-20210823234141088](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210823234141088.png)

索引的叶节点都指向记录在磁盘上的物理位置，即行号。

![image-20210823234054075](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210823234054075.png)



##### 覆盖索引

待查询的数据可以全部由索引在索引中找到



##### 索引的三星系统

该系统用于评价一个索引在多大程度上助力某个查询。

索引将相关的记录放在一起获得一星——InnoDB采用BTree索引和聚簇索引，所以基于主索引的查询可以获得一星；

索引中的数据顺序和查找中的数排列顺序一致则获得二星；

索引中的列包含了查询中需要的全部列则获得三星；——对应覆盖索引



##### 高性能索引策略

基本原则：具体情况，具体讨论。因此这部分后续结合实际案列来讲解。













