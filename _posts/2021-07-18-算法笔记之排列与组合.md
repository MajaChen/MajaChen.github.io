---
layout: post
title: 算法笔记之排列与组合
subtitle: algorithm arrange combine
cover-img: /assets/img/greenmountain.jpg
thumbnail-img: /assets/img/parrot.jpg
share-img: /assets/img/greenmountain.jpg
tags: [algorithm]
---

# 算法笔记之排列、组合

## 1.从一个数字全排列问题说起

&emsp;&emsp;每次从基本阿拉伯数字集(0 1 2 3 4 5 6 7 8 9)中选择出其中一个数字，选择n次，将选择的数字按照选择的顺序组合成一个新的数字，比如第一次选择1，第二次选择2，那么组合后的数字就是12，问所有可能的组合数字。我把这个问题称为数字全排列问题。

 ![image-20210709213906721](https://gitee.com/xinyuanchen/image_collection/raw/master/image-20210709213906721.png)

&emsp;&emsp;解法1——基于递归，以自顶向下的方式求解,在求解的过程中加入一个map避免重复计算。

```
var computed map[int][]strings.Builder//使用之前需要初始化

func arrangeNumsRe(n int) []strings.Builder {
	if n == 0 {
		computed[0] = make([]strings.Builder, 1)
		return make([]strings.Builder, 1)
	}
	res := make([]strings.Builder, 0)
	for i := 0; i < 10; i++ {
		var tmpRes []strings.Builder
		var ok bool
		if tmpRes,ok = computed[n-1];!ok{
			tmpRes = arrangeNumsRe(n-1)
		}
		
		for _, re := range tmpRes {
			pre := strings.Builder{}
			pre.WriteString(strconv.Itoa(i))
			pre.WriteString(re.String())
			res = append(res, pre)
		}
	}

	delete(computed,n-1)
	computed[n] = res
	return res
} 
```

&emsp;&emsp;解法2——非递归，以自底向上的方式求解，先求解最基本的子问题，然后不断地组合子问题。

```
func arrangeNumsNoRe(n int)[]strings.Builder{
	res := make([]strings.Builder,1)
	for i := 0;i < n;i++{

		var sres []strings.Builder
		for j := 0;j < 10;j++{
			for _,re := range res{
				var pre strings.Builder
				pre.WriteString(strconv.Itoa(j))
			    pre.WriteString(re.String())
				sres = append(sres, pre)
			}
		}
		res = sres

	}
	return res
}

```

&emsp;&emsp;类似的问题还有26个英文大(小)写字母的全排列。

## 2.引入排列、组合

&emsp;&emsp;排列、组合的详细定义和计算公式可以参考[知乎网友的解答]()。这里我概括一下排列、组合的基本概念，重点是如何用代码来实现排列和组合。<br>
&emsp;&emsp;**排列：**从m个元素中，选出n(n <= m)个元素组成一个子集，子集内n个元素的顺序有要求，即任意两个子集，即使他们包含相同的元素，但如果元素的顺序不一样，则这两个子集是不同的子集，对应两个不同的排列。<br>
&emsp;&emsp;举例：现有8位选手，3座奖杯(金、银、铜)，每位选手都可能获得任一奖项，也可能不获得任意奖项。列出选手获奖的所有可能情况。这个问题抽象一下就是：从8个元素中，选出其中3个元素组成一个子集，子集内不能出现重复的元素，一个人不可能既获得金奖，又获得铜奖，否则就是作弊。问子集的所有可能情况，代码如下

```
func arrange(candidates []string, n int, visited map[string]bool) []strings.Builder {
	if n == 0 {
		return make([]strings.Builder, 1)
	}

	res := make([]strings.Builder, 0)
	for i := 0; i < len(candidates); i++ {
		if visited[candidates[i]] {
			continue
		}
		visited[candidates[i]] = true
		tmpRes := arrange(candidates, n-1, visited)
		visited[candidates[i]] = false
		for index, re := range tmpRes {
			re.WriteString(candidates[i])
			tmpRes[index] = re
		}
		res = append(res, tmpRes...)
	}
	return res
}
```

&emsp;&emsp;**获奖问题相比于数字全排列问题，区别在于同一个元素不能在一个集合中反复出现。**由于这个限制的存在，获奖问题用自底向上的方式不太好求解，而且也不便于借助map来避免重复计算。<br>
&emsp;&emsp;**组合：**从m个元素中，选出n(n <= m)个元素组成一个子集，不考虑子集内n个元素的顺序关系，即任意两个子集，只要他们包含相同的元素，则这两个子集是相同的子集，对应两个相同的组合。<br>
&emsp;&emsp;举个例子：现有8位选手，3座奖杯，每位选手都可能获得任一奖项，也可能不获得任意奖项，但是这里的奖项已经不区分金、银、铜了，只有获奖与不获奖之分。要求列出选手获奖的所有可能情况。<br>
&emsp;&emsp;整个问题基于递归求解会比较方便，而且求解思路与排列问题不太一样，代码如下：

```
func combine(strs []string,n int)[]strings.Builder{

	if n == 1{
		res := make([]strings.Builder,0,len(strs))
		for _,str := range strs{
			builder := strings.Builder{}
			builder.WriteString(str)
			res = append(res, builder)
		}
		return res
	}

	res := make([]strings.Builder,0)
	for i := 0;i <= len(strs)-n;i++{
		tmpRes := combine(strs[i+1:],n-1)
		for index,re := range tmpRes{
			re.WriteString(strs[i])
			tmpRes[index] = re
		}
		res = append(res, tmpRes...)
	}
	return res
}
```
## 总结

&emsp;&emsp;这几处代码看似简单，但是写起来却大费周章，历经了多次调试才终于输出了正确的结果,有如下几个需要注意的点：<br>
&emsp;&emsp;1.采用递归求解方式要特别注意递归的出口；<br>
&emsp;&emsp;2.以数字全排列问题为例，如果每种排列用一个一维字符串数组来表示，那么所有的排列结果就得用一个二维字符串数组来表示，用高维度数组这种数据结构，务必要弄清楚每一维表达的含义，否则很容易晕头转向。这里完全可以用一个strings.Builder的一维数组来代替二维数组，每个strings.Builder表示一个维度。









